# JAVA
1. JVM의 기본 구조
- 클래스 로더 : 런타임 시 동기적으로 클래스를 로드, 바이트 코드를 배치
- 실행 엔진 : 배치된 바이트 코드를 실행 가능하도록 해석
- 메모리 영역(Runtime data areas) : 클래스 데이터 및 실제 데이터가 저장되는, os로부터 할당 받은 메모리 영역

<br><br>

2. 메모리 영역의 종류
- Method Area : 클래스 정보 저장
- Heap : 객체와 배열 저장. 가비지 컬렉터 목표 공간
- stack : 스택 프레임이 저장되는 공간. 스택 프레임엔 호출된 메소드의 변수와 리턴 주소 등이 기록되어 있음
- PC Register : 실행 중인 명령어의 주소. 곧 메소드 영역 어딘가를 가리킨다.
- Native Method Stack : 자바 외 언어로 작성된 코드 수행 영역. 자바 영역과 분리된다.

<br><br>

3. JVM의 특징
- 바이트 코드를 기계어로 변환
- 스택 기반 가상 머신
- 메모리 관리, 가비지 컬렉션

<br><br>

4. JVM이 플랫폼 독립적인 이유를 설명해 주세요.

- 바이트 코드를 실행하기 때문. 프로그래밍 언어를 이진 언어로 컴파일한다면 os나 하드웨어에 따라 달라지는 부분(시스템api, 파일 처리, 경로 관리 외)을 다르게 코딩해야함.  
jvm은 자바 코드를 실행 가능한 바이트 코드로 변환한 후 플랫폼에 알맞은 jvm이 적절한 기계어로 변환된다.

<br><br>

5.  Call by Value와 Call by reference의 정의
- Call by Value 원본 값과 전달한 값이 메모리 측면에서 동일하지 않음. 새로운 복사본
- Call by reference 원본 값과 전달한 값이 메모리에서 완전히 동일함

<br><br>

6. 자바에 Call by reference가 없는 이유
- ~~자바 창시자가 그렇게 만들었다는데요~~  
참조타입의 경우 Call by reference로 동작하는 듯 보임.
그러나 객체는 heap에 저장되고, 변수는 stack에 저장됨.
스택에 저장된 변수(즉, 객체의 주소) 자체는 별개로 저장됨.
만약 참조타입이 Call by reference였다면,
a = 0x0001; b = 0x0001 이라 할 때 b의 주소값을 변경했을 때 a의 주소값도 변경되어야 했을 것

<br><br>

# OOP

1. 객체지향 프로그래밍의 4대 원칙을 설명해 주세요.

- 캡슐화 : 데이터 및 연관된 메소드를 하나의 객체로 만들고, 외부에서 직접 접근을 제한
- 상속 : 기존 클래스를 기반으로 새로운 클래스 생성. 코드 재사용성 증가
- 다형성 : 동일한 메소드명에 서로 다른 기능을 구현할 수 있게 하는 것. 오버라이딩과 오버로딩 등
- 추상화 : 복잡한 기능에서 불필요한 사항은 제거, 공통성과 핵심 기능을 추출하여 표현. 세부 기능은 감추고 사용자가 원하는 기능을 수행할 수 있도록

<br><br>

2. OOP 설계 시 SOLID 원칙

- Single Responsibility Principle (SRP): 단일 책임 원칙, 하나의 클래스는 하나의 책임만 가진다
- Open/Closed Principle (OCP): 개방 폐쇄 원칙, 클래스는 확장에 대해 열려 있어야 하며, 수정에 대해서는 닫혀 있어야 함
Liskov Substitution Principle (LSP): 리스코프 치환 원칙, 자식 클래스는 부모 클래스에서 가능한 행위를 항상 수행해야함
- Interface Segregation Principle (ISP): 인터페이스 분리 원칙, 인터페이스는 클라이언트가 필요한 기능만을 가져야함
- Dependency Inversion Principle (DIP): 의존 역전 원칙, 상위 모듈은 하위 모듈에 의존하지 않아야함. 하위의 변경이 상위로 갈 수 없음

<br><br>

# 프레임워크
1. IoC와 DI의 차이점

- IoC : 객체 생성과 의존성 주입의 제어를 개발자가 아닌 프레임워크가 담당하는 디자인
- DI : IoC의 하위 방식. 객체가 다른 객체의 의존성을 외부에서 주입받는 방식

<br><br>

2. DI 방식의 종류

- Constructor Injection(생성자 주입) : 생성자를 통한 의존성 주입. 객체가 불완전하게 생성될 위험이 없음.
- Setter Injection(세터 주입) : 세터를 통한 의존성 주입. 객체가 생성된 이후에 의존성을 주입할 수 있음.

<br><br>

3. AOP기법

- 횡적 관심사 기법. 핵심 로직과 별개로 존재. 보안, 로깅 등 공통 관심사를 따로 분리하여 처리.
스프링에서 @Transactional에서 사용. 트랜젝션은 여러 작업을 하나로 묶어 공동의 성패로 처리. 실패 시 자동으로 롤백. 이 기능에서 AOP는 핵심 로직과 별개로 트랜젝션 관리에 사용.

<br><br>

# CS
1. TCP와 UDP의 차이점

- TCP : 신뢰성 높은 전송 프로토콜.  
전송 전에 연결, 전송이 끝나면 연결 종료.  
매번 응답을 기다리므로 전송이 느림.  
흐름 제어가 가능하며 손실 발생 시 재요청을 통해 재전달.

<br>

- UDP : 송수신 순서를 보장하지 않으며, 데이터 손실과 중복 발생도 가능.  
연결하지 않으므로 속도가 빠름.  
흐름 제어가 없으며 손실 시 수신 측에서 별도의 오류 처리 필요.

<br><br>

2. TCP/UDP의 용례

- TCP : 정확한 데이터가 필요한 웹, 파일 전송, 이메일 등
- UDP : 실시간 통신이 필요한 스트리밍, 게임 등