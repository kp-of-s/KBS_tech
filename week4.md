# 클로저 (Closure)

## 클로저란?
**클로저**는 **함수와 그 함수가 선언될 당시의 스코프**를 함께 기억하는 특성.<br>
내부 함수가 외부 함수의 변수에 접근할 수 있도록 하는 함수.<br>
외부 함수가 종료된 후에도 내부 함수는 외부 함수의 지역 변수에 접근할 수 있음. <br>

## 클로저의 동작 원리
**스코프 체인**을 기반으로 동작하는 클로저는, **변수의 생명주기**와 **참조**를 기억하고 관리하는 역할.<br>
외부 함수가 종료되었어도, 내부 함수는 **외부 함수의 변수를 계속 참조 가능**.<br>

- **스코프 체인**: 클로저는 **어휘적 스코프(lexical scope)**를 따르기에, 함수가 선언된 위치에서 참조할 수 있는 변수들을 기억함.<br>
- **실행 컨텍스트**: 클로저는 **실행 컨텍스트**의 정보를 저장해서, 외부 함수가 종료된 후에도 외부 함수의 지역 변수들을 참조할 수 있음.<br>

## 클로저가 중요한 이유

- > **상태 캡슐화**: 외부에서 직접 접근할 수 없는 변수를 내부 함수만 제어할 수 있도록 하여, 객체 지향 프로그래밍에서의 **정보 은닉**과 유사한 방식으로 사용됨.<br>
  
- > **데이터 은닉**: 특정 변수나 상태를 외부에서 접근할 수 없도록 보호하면서, 필요한 인터페이스만 공개할 수 있음. 이는 **모듈화**를 구현할 때 유용함.<br>

- > **부분 적용(Partial Application)**: 클로저는 일부만 미리 제공하고, 나중에 나머지 인자들을 전달해서 함수를 부분적으로 실행할 수 있는 기능을 제공.<br>
이는 함수형 프로그래밍에서 **커링(Currying)**과 같은 기법에 활용됨.

## 클로저의 성능 고려사항

- **메모리 관리**: 클로저를 사용할 때, 참조하는 외부 변수들이 더 이상 필요치 않다면, 이를 `null`로 설정, **가비지 컬렉션**이 돌아가도록 유도.<br>
  
- **성능 고려**: 클로저를 사용할 때, 필요 이상으로 **불변 객체를 참조**하거나 **대용량 데이터를 참조**하는 경우, 성능에 좋지 못한 영향을 끼침.<br>




# this 바인딩

## 정의
함수가 호출될 때마다 **동적**으로 결정되는 특별객체.<br>
함수가 **속한 객체**를 가리키며, 그 값은 함수가 호출되는 방식에 따라 달라짐.<br>

## `this` 바인딩의 규칙

### 1. 전역 컨텍스트에서의 `this`
> 전역에서 `this`는 **전역 객체**를 참조.<br>
브라우저 환경 = `window` 객체<br>
Node.js 환경 = `global` 객체

### 2. 일반 함수에서의 `this`
> 일반 함수에서 **전역 객체** 참조

### 3. 메서드에서의 `this`
> 객체의 메서드 내에서 해당 메서드를 호출한 **객체** 참조.

### 4. 생성자 함수에서의 `this`
> 생성자 함수에서 새로 생성된 **인스턴스 객체** 참조.

### 5. `call()`, `apply()`, `bind()`에서의 `this`
> 명시적으로 this 설정 가능한 객체들.
> - **`call()`**: 즉시 실행되며, `this`를 첫 번째 인자로 전달한 객체로 설정함.
> - **`apply()`**: `call()`과 유사하지만, 인자를 배열로 전달함.
> - **`bind()`**: `this`를 지정하고 함수를 반환함. 반환된 함수는 나중에 호출할 수 있음.

## `this`와 화살표 함수
화살표 함수 내에서는 **함수가 선언된 위치**의 `this`를 참조.<br>
일반 함수는 호출될 때마다 `this`가 바뀌지만, 화살표 함수는 `this`가 변경되지 않고, **외부 컨텍스트**의 `this`를 유지함.




# Promise & async/await

## Promise의 정의
**비동기 작업의 완료 또는 실패와 그 결과 값을 나타내는 객체**.<br>
작업이 끝난 후 수행할 후속 작업을 등록함.<br>
Promise를 사용하면 콜백 함수 대신 **체이닝**을 사용하여 코드 흐름을 관리할 수 있음.

## 상태
3가지 상태를 가짐:
1. **대기(pending)**: Promise가 아직 완료되지 않음. 비동기 작업이 진행 중임.
2. **이행(fulfilled)**: 비동기 작업이 성공적으로 완료됨. 값이 반환됨.
3. **거부(rejected)**: 비동기 작업이 실패함. 오류가 발생함.

## async/await란?
**`async`** - **비동기 함수**를 정의하는 키워드.<br>
**`await`** - **Promise가 처리될 때까지 기다리게 하는 키워드**.<br>
Promise를 더 직관적이고 간결하게 다룰 수 있도록 만들어줌.<br>
**`async` 함수**는 항상 **Promise를 반환**하며, **`await`는 Promise가 해결될 때까지 기다림.**

## Promise와 async/await의 차이점

### Promise
- > **체이닝**을 통해 `.then()` 또는 `.catch()` 메서드를 사용해 후속 작업을 등록함.<br>
- > 비동기 작업이 완료될 때까지 기다리지 않고 **콜백 함수**를 사용하여 비동기 흐름을 관리함.

### async/await
- > **`async`와 `await`를 사용하면 비동기 코드를 동기처럼 작성**할 수 있음.<br>
- > **`await`는 Promise가 해결될 때까지 기다리기 때문에 코드가 더 직관적이고 읽기 쉬움.**

## Promise와 async/await의 성능 차이
- **Promise**는 여러 비동기 작업을 동시에 실행할 수 있는 유연함이 있음. `.all()`이나 `.race()` 등을 사용하여 여러 Promise를 동시에 처리할 수 있음.
- **async/await**는 직관적이고 코드가 깔끔하지만, **병렬 처리**가 필요할 경우에는 `Promise.all()`과 같은 방식을 사용해야 함.




# 단일 책임 원칙 (Single Responsibility Principle)

## 단일 책임 원칙(SRP)
객체지향 설계에서 중요한 5가지 원칙 중 하나인 **SOLID** 원칙 중 하나.<br>
클래스나 모듈은 하나의 책임만 가져야 한다.<br>
코드의 **변경 용이성**과 **유지보수성**을 높이기 위함.

## 중요성
**각 클래스가 특정한 책임만 가지므로 수정 시 영향을 미치는 부분 최소화** 가능<br>
**응집력 높은** 클래스를 만들 수 있어, 코드의 **가독성**과 **테스트 용이성**이 향상됨.<br>
이 원칙을 지키면 시스템의 **변경에 유연한** 구조 개발 가능.

## 단일 책임 원칙을 지키는 방법
1. **클래스가 하나의 책임만 가지도록 설계**.<br>
   클래스를 설계할 때, 해당 클래스가 하나의 역할만 수행하도록 구현.

2. **기능을 구체화하고 모듈화**.<br>
   너무 많은 기능을 가진 클래스는 유지보수가 어려워짐. 클래스를 작은 단위로 나누어 하나의 책임만 다루도록 설계함.

3. **변경이 발생할 가능성이 있는 부분을 분리**.<br>
   기능이 추가되거나 변경될 때 영향을 미치는 부분을 구분하고, 그 기능을 독립적인 클래스로 분리함.

4. **명확한 인터페이스 제공**.<br>
   클래스가 맡고 있는 책임이 무엇인지 명확하게 정의하고, 다른 클래스가 해당 클래스를 사용할 때 어떤 방식으로 사용할 수 있는지 알 수 있도록 인터페이스를 정의함.

## 지키지 않았을 때의 문제점
1. **응집력 부족**: 하나의 클래스가 여러 책임을 가지면, 클래스 내의 코드가 서로 관련이 없는 부분으로 나뉘게 되어, **응집력**이 떨어짐.
2. **유지보수 어려움**: 클래스의 책임이 많을수록 **수정 시 발생할 수 있는 영향 범위가 넓어짐**. 단 하나의 변경이 다른 기능에 영향을 미칠 수 있음.
3. **테스트 어려움**: 다양한 책임을 가지는 클래스는 **단위 테스트**를 작성하기 어려움. 각 기능을 독립적으로 테스트하기 어려운 상황이 발생할 수 있음.




# 데이터베이스: 트랜잭션 ACID 원칙

## 트랜잭션이란?
**하나의 논리적 작업 단위**.<br>
트랜잭션은 **모든 작업이 성공적으로 완료되거나, 하나라도 실패하면 모두 취소**되는 식으로 관리.<br>
데이터의 일관성을 보장 가능.

## ACID 원칙

### 1. Atomicity (원자성)
**트랜잭션이 "모두 실행되거나, 전혀 실행되지 않거나"** 보장.<br>
트랜잭션 내 모든 작업은 하나의 단위로 처리, 문제 발생 시 **전체 작업이 취소**.<br>
따라서, **작업의 일관성을 유지**함.

### 2. Consistency (일관성)
**트랜잭션이 완료된 후 DB가 일관된 상태를 유지해야 한다**.<br>
트랜잭션 수행 전후에 **DB 규칙과 제약 조건**이 만족되어야 하며, 데이터는 항상 유효한 상태여야 함.<br>

### 3. Isolation (격리성)
**각 트랜잭션이 독립적으로 실행되어야 한다**.<br>
하나의 트랜잭션이 다른 트랜잭션에 영향을 미치지 않도록 보장. 여러 트랜잭션이 동시에 실행될 때도 **서로 격리되어 실행**되어야 함.

### 4. Durability (지속성)
**트랜잭션이 완료된 후에는 그 결과가 영구적으로 저장되어야 한다**.<br>
트랜잭션이 성공적으로 완료될 때, 그 결과는 **영구적으로 저장되며**, 시스템 오류가 발생하더라도 **데이터는 손실되지 않음**.<br>
데이터베이스는 트랜잭션이 성공적으로 완료된 후 **로그 파일**이나 **디스크**에 데이터를 기록하여, 장애가 발생해도 데이터를 복구할 수 있도록 함.
  
## 트랜잭션의 관리
트랜잭션은 **데이터베이스 관리 시스템(DBMS)**에 의해 관리되며, **트랜잭션 로그**를 사용하여 트랜잭션의 성공 또는 실패를 기록함.<br>
- **Commit**: 트랜잭션이 성공적으로 완료되면, 데이터베이스에 영구적으로 반영됨.
- **Rollback**: 트랜잭션 도중 오류가 발생하면, 트랜잭션 이전 상태로 되돌려놓음.




# 리액트의 상태 관리: useState vs useReducer

## useState
리액트의 **기본적인 상태 관리 훅**.<br>
**상태를 변경할 수 있는 변수, 상태를 업데이트하는 함수를 반환**.<br>

### 특징
> - **간단한 상태 업데이트**: `useState`는 상태의 초기값과 업데이트 함수를 반환함.
> - **상태 변경 간단**: 상태를 직접 수정하는 대신, **업데이트 함수를 호출**해서 상태를 변경함.
> - **로컬 상태 관리**: 보통 **컴포넌트 수준에서만** 상태를 관리하는 경우 유용.

## useReducer
**useState보다 더 복잡한 상태 로직**을 처리할 때 유용한 훅.<br>

### 특징
> - **reducer 함수 사용**: `useReducer`는 상태 변화에 대한 로직을 **reducer 함수**에 위임.
> - **복잡한 상태 관리**: 여러 상태를 관리하거나, 상태 변화가 복잡할 때 유용.
> - **디스패치 방식**: 상태 업데이트는 **dispatch** 함수와 **액션** 사용.

## useState와 useReducer의 차이점

### 1. 사용 목적
- `useState`는 **단순한 상태 관리**를 위해 사용됨.
- `useReducer`는 **복잡한 상태 관리**나 **여러 상태를 함께 관리**해야 할 때 적합함. **다양한 액션에 따른 상태 변화**, **컴포넌트의 상태가 복잡할 때** 등등.

### 2. 코드 구조
- `useState`는 **단일 변수**로 상태를 관리, 업데이트는 간단한 **업데이트 함수**를 통해 이루어짐.
- `useReducer`는 **reducer 함수**를 사용하여 상태를 관리, 상태 업데이트가 필요한 경우 **액션**을 디스패치함.

### 3. 성능 최적화
- `useState`는 상태가 변경될 때마다 해당 컴포넌트가 리렌더링됨. 상태가 변경될 때마다 **리렌더링**이 발생하지만, 상태가 간단할 경우 성능에 큰 영향을 미치지 않음.
- `useReducer`는 **dispatch**를 통해 상태를 변경하므로, 상태 변화가 여러 번 발생하는 경우 **상태 변화가 모여서 한 번에 리렌더링**될 수 있기에, 성능 최적화에 유리.

### 4. 코드의 복잡성
- `useState`는 코드가 간결하고 이해하기 쉬움.
- `useReducer`는 **코드가 길고 복잡**해짐. 여러 액션에 대한 로직을 `reducer` 함수 안에서 처리하기 때문에, 상태 변화가 많을 때 코드가 길어짐.