# 2주차 개념 정리

## var, let, const 차이

### var
- 과거에 사용되던 변수 선언 방식
- 함수 스코프를 가짐
  - `var`로 선언된 변수는 그 변수가 선언된 함수 내에서만 유효함.
- 중복 선언 가능
  - 같은 함수나 코드 블록 내에서 동일한 이름의 변수를 여러 번 선언할 수 있음.
<br>

### let
- 블록 스코프를 가짐
  - `let`으로 선언된 변수는 그 변수가 선언된 블록 내에서만 유효함.
- 중복 선언 불가
  - 동일한 코드 블록 내에서 같은 이름의 변수를 `let`으로 두 번 선언하면 오류가 발생함.
<br>

### const
- let과 비슷하지만, 값이 변경될 수 없음
- 블록 스코프를 가짐
  - `const`로 선언된 변수는 그 변수가 선언된 블록 내에서만 유효함.
- 재할당 불가
  - 선언한 변수에 값을 다시 할당할 수 없음.<br>
  하지만 객체나 배열의 내부는 변경할 수 있음.
<br>

## 호이스팅 (Hoisting)
호이스팅은 변수 선언과 함수 선언이 코드 실행 전에 최상단으로 끌어올려지는 기능.
- **`var`**:
  - 변수 선언만 호이스팅됨, 값은 호이스팅되지 않음.
  - 예시:
    ```javascript
    console.log(a);
    var a = 5;
    ```
    - a는 호이스팅되어 최상단에 선언이 끌어올려짐.<br>
    그러나 값은 할당되지 않아 undefined가 출력.
- **`let`과 `const`**
  - `let`과 `const`는 선언이 호이스팅되지만, 초기화되기 전까지는 접근할 수 없음.
  - 이 구간을 TDZ라고 하며, 이 구간에서 접근하려고 하면 레퍼런스 에러 발생.
  - 예시:
    ```javascript
    console.log(a);
    let a = 5;
    ```
- **함수 선언**
  - 함수 선언은 함수 자체가 호이스팅되므로, 언제나 사용 가능함.
  - 예시:
    ```javascript
    myFunction();

    function myFunction() {
        console.log("Hello, World!");
    }
    ```
- **함수 표현식**
  - 함수 표현식은 변수와 비슷하게 값은 초기화 이후 사용 가능.<br>
  이때 var로 선언되었다면 타입에러가, let 혹은 const로 선언 시 레퍼런스 에러가 발생.
  - 예시:
    ```javascript
    console.log(myFunction());

    var myFunction = function() {
        console.log("Hello, World!");
    };
    ```
<br>

## TDZ (Temporal Dead Zone)

### 개념
- Temporal Dead Zone (TDZ)는 let 혹은 const 변수 자체는 호이스팅 되었으나 값은 사용할 수 없는 상태를 말함.
- 이때 레퍼런스 에러가 발생하며, 이를 회피하기 위해선 선언 및 초기화 후 사용해야함
<br><br><br>

## 프로세스 (Process)

### 정의
- **실행 중인 프로그램**
- 독립적인 메모리 공간에 자신의 코드, 데이터 등등이 있음
- OS는 각 프로세스를 PID로 구분
<br>

### 특성
- 독립성: 각 프로세스는 독립된 메모리 공간(코드, 데이터, 스택, 힙)을 가짐. 따라서 상호 접근도 영향도 불가.
- 자원 할당: OS로부터 시간과 메모리 등을 할당 받음.
- 상호작용: 각 프로세스 간 상호작용이 필요한 경우 별개의 IPC 기법 필요.
- 스케줄링: OS에 의해 우선순위와 실행 순서가 결정됨.
<br>

### 생성 및 종료
- 시스템 호출을 통해 생성되고 종료되며 운영체계에 의해 제어됨
<br>

## 스레드 (Thread)

### 정의
- **프로세스 내에서 실행되는 단위 작업**
- 프로세스 내 스택 메모리를 제외한 공간을 공유함

### 특성
- 경량화: 프로세스에 비해 월등히 가벼움.
- 자원 공유: 같은 프로세스 내에서 실행된다면 메모리와 변수를 공유. 그러나 독립적인 실행 흐름을 가짐.
- 동기화: 다수의 스레드가 같은 변수에 접근하거나 호출 순서가 꼬일 수 있기 때문에 동기화 기법을 사용해야함

### 2.3 생성 및 종료
- 프로세스 내에서 생성되며 프로세스보다 먼저 종료됨
<br>

## 3. 프로세스와 스레드의 차이점
본래 프로그램을 실행하기 위한 것이 프로세스임.<br>
프로그램이 거대해지고 다양한 흐름을 가짐에 따라 하위 실행단위가 필요해 스레드가 만들어짐<br>
따라서 프로세스는 거대하고 무거우며, 기본적으로 다른 프로세스와 간섭이 어렵도록 만들어짐<br>
하지만 스레드는 하나의 프로세스 내에서 동작하므로, 효율적으로 메모리를 사용하고 같은 메모리를 사용함<br>
<br>

## React vs Vue vs Svelte 비교
### React
- `React`는 UI를 구성하기 위한 컴포넌트 기반의 접근 방식
- 가상 DOM을 사용하여 변경된 부분만을 실제 출력되는 화면에 표시하는 방식
- `JavaScript`로 작성되며, JSX를 사용.

> - 강점:
>   - 거대한 생태계
>   - 컴포넌트 재사용성
>   - 대규모 애플리케이션에 적합
>   - 성능이 뛰어난 가비지 컬랙터, 메모리 관리 기능을 지원

> - 단점:
>   - 오로지 view 기능만 지원하기에, 그 외 기능은 배경 지식 필수
>   - 긴 로딩시간
>   - 복잡해질 수 있는 컴포넌트 구조 및 상태 관리
<br>

### Vue
- 직관적이고 간단한 템플릿 문법
- 가상 DOM을 사용, 컴포넌트 기반 UI 구축
- `JavaScript`를 기반으로 하며, **템플릿**과 **옵션 API** 또는 **Composition API**를 사용하여 개발

> - 강점:
>   - 학습 곡선이 낮고 직관적인 문법
>   - 양방향 데이터 바인딩 지원
>   - 빠른 개발을 지원하며, 확장성이 뛰어남
>   - 라우터, 상태 관리 등에서 내장기능이 다양함

> - 단점:
>   - 작은 생태계
>   - 대형 프로젝트에서 유연성 부족
<br>

### Svelte
- `Svelte`는 컴파일 타임에 최적화를 수행, 실제 출력되는 DOM을 직접 조작
- `JavaScript`, `HTML`, `CSS`를 하나의 파일에 작성할 수 있음
- 반응형 상태 관리가 내장

> - 강점:
>   - 컴파일 타임 최적화
>   - 간결하고 직관적인 코드
>   - 상태 관리와 UI 업데이트가 자동으로 처리됨
>   - 빠른 성능

> - 단점:
>   - 매우 작은 생태계
>   - 기존 라이브러리와의 통합에서 문제가 발생 가능성

## 요약

- React는 대규모 앱에 적합하며, 넓은 생태계에서 오는 라이브러리가 강점
- Vue는 직관적인 템플릿 기반 문법으로 빠른 개발 가능
- Svelte은 뛰어난 성능과 간결한 코드를 갖춰 성능이 중요한 애플리케이션에 적합