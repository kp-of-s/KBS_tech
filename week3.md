# Garbage Collection(GC)

## 자바에서 가비지란?
힙 메모리 영역에 생성되는 유효하지 않은 메모리.<br>
더 이상 참조되지 않는 객체.

## 가비지 컬렉터란?
JVM에서 가비지를 자동으로 해제하는 것.<br>
본래 C언어 등에선 `free()`등을 사용해 직접 메모리를 해제해야 했지만, 자바는 GC가 한 번씩 돌면서 해제해준다.

## GC의 직접 호출
`System.gc()`로 직접 호출은 가능하지만 권장되지 않는다.<br>
- 실행 여부는 여전히 GC의 몫이기에 즉각 실행에 대한 보장이 없다.<br>
- Full GC 발생 시 GC가 실행되는 스레드를 제외한 모든 스레드가 멈추는 STW(Stop-The-World)가 발생.<br>
- 이미 최적화된 GC 튜닝을 무시하기에, 역효과가 날 수 있음.

## 힙 메모리의 영역
자바의 Heap은 2가지 전제를 가지고 설계됨.<br>
대부분의 객체는 금방 접근 불가능한 상태가 된다 + 오래된 객체가 새로운 객체로의 참조는 아주 드물다 = 대부분의 객체는 일회용이다.<br>
따라서 대부분의 일회용 객체가 저장될 메모리와 거대하거나 장수하는 객체가 저장될 메모리가 물리적으로 분리됨.<br>

이때 old 영역의 Young 영역 참조를 효과적으로 수행하기 위해, 참조하는 객체의 정보를 저장하는 카드 테이블이 존재함.<br>
GC는 실제 Old 메모리를 전부 확인함으로 참조하는 객체를 확인하는 대신, 카드 테이블만을 확인하여 삭제할 객체를 결정함.

### Young 영역
- 새로 만들어진 객체들이 저장되는 영역.<br>
- Eden 영역과 survivor 영역으로 나뉨.<br>
- 크기가 작고, GC가 자주 돌며 그 시간은 크지 않음.<br>
- 마이너 GC가 관리함.

### Old 영역
- 크기가 큰 객체, 혹은 오랫동안 살아남은 객체가 저장되는 영역.<br>
- GC가 자주 돌지 않으며 그 시간은 오래 걸림.<br>
- 메이저 GC가 관리함.

## Minor GC
Eden 영역이 꽉 차면 실행함.<br>

방금 생성된, 즉 age가 0인 객체들은 eden에 저장됨.<br>
GC이 한 번 돌면, age가 증가하고 survivor 영역으로 이동.<br>

survivor 영역은 1영역과 2영역으로 나뉨(s1과 s2라 칭하겠음).<br>
기존에 s1에 객체가 저장되고 있었다면 s1에서 살아남은 객체들은 s2로 이동하며 age가 증가함.<br>
이를 반복하며 age가 충분히 커진다면 old 영역으로 이동함.

## Major GC
Old 영역이 꽉 차면 실행.<br>

객체가 접근 가능한지 판명하고, 메모리를 해제하는 단순한 과정이지만 그 크기 때문에 굉장히 오랜 시간이 걸림.

## Full GC
특히 마이너/메이저 GC를 동시에 돌리는 Full GC 상황에선 STW가 엄청남.<br>
따라서 다양한 알고리즘을 통해 이 시간을 최적화하기 위한 노력이 있었음.

## GC 종류

### Serial GC
- minor 영역에서는 Mark Sweep (확인 후 메모리 해제)만 진행하지만, major 영역에서는 정리를 추가하여 사용되는 객체와 사용되지 않는 객체를 분리하는 것.<br>
- 단일 스레드를 목적으로 만든 방식이므로 멀티 스레드에서 사용은 권장되지 못한다.

### Parallel GC
- Java8의 디폴트.<br>
- 시리얼과 거의 같지만, Young 영역에서 멀티 쓰레드로 이를 진행한다.


### Parallel Old GC
- Old 영역도 멀티 쓰레드 지원.

### CMS GC
- STW 시간을 줄이는데 집중하여 프로세스 자원을 땡겨오고 Compaction 단계를 수행하지 않는 방식.<br>
- 자원이 많이 들고, Compaction 없어 메모리 조각화가 심해지면 Full GC가 돌아가야함.<br>
- Java14 이후엔 사용중지된 기술.

### G1
- 메모리를 물리적으로 나누는 것이 아닌, Region으로 나눔.<br>
- 각 리전을 동일한 크기로 나누고 역할 별로 구분하여 가비지가 많은 레기온을 우선적으로 GC 수행.<br>

이때 Humongous와 Availabe/Unused라는 영역이 추가되는데, Humongous는 레기온 크기의 절반이 넘는 객체를 저장하는(즉, 거의 항상 용량 차지 상위권인) 리전임.<br>
Unused는 사용되지 않는 리전이며, 기존 GC에서 서바이벌 영역이 s1과 s2로 나뉘어져 번갈아 사용되던 것처럼 동작함.<br>
Eden 영역에 GC가 돌면 기존 Unused가 서바이벌 영역으로 취급받고, 이때 비워진 Eden은 Unused 영역이 됨.<br>

기존 GC가 Heap영역을 전부 탐색하며 가비지를 찾았다면 G1은 Heap의 특정 레기온만을 탐색하므로, 다 잦게 수행되지만 훨씬 더 짧은 시간이 소요됨.<br>

Java9부터 디폴트 방식임.<br><br><br>



# String, StringBuffer, StringBuilder

## String
자바에서 `String`은 불변 객체로, 한 번 생성된 문자열은 수정할 수 없다.<br>
따라서 문자열을 변경할 때마다 새로운 `String` 객체가 생성된다.<br>
이로 인하여 성능에 영향을 미칠 수 있으므로 문자열을 자주 변경해야 할 경우에는 `StringBuffer`나 `StringBuilder`를 사용하는 것이 좋음.<br>

- **불변 객체**: `String` 객체의 값을 변경할 수 없으며, 새로운 객체가 생성된다.<br>
- **스레드 안전**: `String`은 불변 객체이기 때문에 여러 쓰레드에서 안전하게 사용할 수 있다.<br>
- **메모리 효율**: 자주 변경되는 문자열을 처리할 때는 메모리 낭비가 발생할 수 있다.

## StringBuffer
`StringBuffer`는 가변(mutable) 객체로, 문자열을 수정할 수 있다.<br>
기본적으로 스레드 안전(thread-safe)하도록 설계되었으며, 동기화를 지원한다.<br>
문자열을 여러 번 수정할 필요가 있는 경우 `StringBuffer`를 사용하면 성능 향상에 도움이 된다.<br>
하지만 스레드 안전성이 필요 없으면 성능을 위해 `StringBuilder`를 사용하는 것이 더 좋다.

- **가변 객체**: 문자열을 수정할 수 있으며, 기존 객체를 수정하는 방식으로 동작한다.<br>
- **스레드 안전**: 동기화(synchronization)가 되어 있어 멀티쓰레드 환경에서 안전하게 사용된다.<br>
- **성능**: 문자열을 자주 수정하는 경우 성능을 향상시킬 수 있다.

## StringBuilder
`StringBuilder`는 `StringBuffer`와 유사하지만, **스레드 안전성**을 제공하지 않는 대신 성능이 더 뛰어나다.<br>
멀티 쓰레드 환경이 아닌 단일 스레드에서 문자열을 자주 수정해야 할 경우 `StringBuilder`를 사용하는 것이 좋다.<br>
`StringBuilder`는 `StringBuffer`와 동일한 방식으로 동작하지만 동기화가 없기 때문에 성능 면에서 우수하다.

- **가변 객체**: `StringBuilder`는 문자열을 수정할 수 있으며, 기존 객체를 수정하는 방식으로 동작한다.<br>
- **스레드 비안전**: 스레드 안전성을 제공하지 않으므로 멀티 스레드 환경에서는 사용하지 않는 것이 좋다.<br>
- **성능**: 동기화가 없기 때문에 `StringBuffer`보다 더 빠르며, 단일 스레드 환경에서 성능이 뛰어나다.<br><br><br>



# 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

## OCP란?
"엔티티는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 객체지향 설계 원칙.<br>
기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있도록 설계해야 함.

## 목적
개방-폐쇄 원칙을 지키면 시스템의 **확장성**과 **유지보수성**이 높아짐.<br>
기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있기 때문에 시스템을 변경할 때 기존 기능에 영향을 주지 않으면서 안정적으로 확장 가능.<br>
이 원칙을 적용하면 새로운 기능을 추가할 때 기존 코드에 버그를 유발할 위험이 줄어들고, 안정적인 시스템 유지가 가능.

## 적용 방법
개방-폐쇄 원칙을 적용하는 방법은 **확장을 위해 인터페이스나 추상 클래스를 사용**하고, 새로운 기능은 기존 코드를 수정하는 대신 추가하는 것임.<br>
즉, 기능을 추가할 때마다 기존 코드를 변경하는 대신, 새 클래스를 추가하거나 기존 클래스를 확장하는 방식으로 시스템을 확장함.<br>
이렇게 하면 기존 코드에 영향을 주지 않으면서도 새로운 기능을 쉽게 추가할 수 있음.<br><br><br>



# CPU 스케줄링

## CPU 스케줄링이란?
CPU를 효율적으로 사용하기 위해, 다수의 프로세스가 동시에 실행될 때 어떤 프로세스에게 CPU를 할당할지 결정하는 과정.<br>
CPU 시간을 효율적으로 분배하여 시스템 성능을 최적화하는 것이 목적이다.

## 스케줄링 알고리즘
CPU 스케줄링을 위해 여러 가지 알고리즘이 존재한다.<br>

> ## 선점형 알고리즘과 비선점형 알고리즘
> CPU 스케줄링 알고리즘은 크게 **선점형(Preemptive)** 알고리즘과 **비선점형(Non-Preemptive)** 알고리즘으로 나뉨.<br>
> 
> - **선점형 알고리즘**: 현재 실행 중인 프로세스를 강제적으로 중단하고, 다른 프로세스에게 CPU를 할당할 수 있음.<br>
> - **비선점형 알고리즘**: 실행 중인 프로세스가 자발적으로 CPU를 반납할 때까지 기다려야 하므로, 프로세스를 중단할 수 없음.

### 1. **FCFS(First-Come, First-Served)**
- 비선점형 알고리즘.<br>
- 프로세스가 도착한 순서대로 CPU를 할당하는 방식.<br>
- 간단하고 직관적이지만, **대기 시간**이 길어질 수 있음.
- 평균 대기 시간이 길어지는 **Convoy Effect**가 발생할 수 있음.

### 2. **SJF(Shortest Job First)**
- 비선점형 알고리즘.<br>
- 가장 짧은 실행 시간을 가진 프로세스에게 CPU를 우선적으로 할당하는 방식.<br>
- 실행 시간이 짧은 프로세스를 먼저 처리하므로 **평균 대기 시간**을 최소화할 수 있음.<br>
- 그러나, 실행 시간을 정확하게 예측하기 어렵기 때문에 긴 프로세스는 프로세스가 실행되지 못하는 **Starvation**이 발생할 수 있음.

### 3. **Priority Scheduling**
- 비선점형 알고리즘.<br>
- 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스에게 CPU를 먼저 할당하는 방식임.<br>
- 우선순위는 시스템에 따라 동적으로 변경될 수 있음.<br>
- **Starvation** 문제가 발생할 수 있는데, 낮은 우선순위의 프로세스는 계속해서 실행되지 않음.

### 4. **Multilevel Queue Scheduling**
- 비선점형 알고리즘.<br>
- 여러 개의 큐를 사용하여 프로세스를 분류하고, 각 큐에서 서로 다른 스케줄링 알고리즘을 사용함.<br>
- 각 큐는 우선순위가 다르며, 큐 간에도 **우선순위**가 부여됨.


### 5. **RR(Round Robin)**
- 선점형 알고리즘.<br>
- 각 프로세스에게 동일한 시간을 할당하고, 그 시간이 끝나면 다른 프로세스로 전환하는 방식.<br>
- 타임 퀀텀(TQ, Time Quantum)을 설정함으로서, 각 프로세스가 일정 시간만큼 CPU를 사용할 수 있도록 함.<br>
- 타임 퀀텀 크기가 너무 크거나 작으면 성능이 저하될 수 있음.

## 스케줄링 기준
스케줄링 알고리즘은 다음 기준에 따라 평가됨.

### 1. **CPU 사용률**
- CPU를 얼마나 효율적으로 사용하는지 평가하는 기준.<br>
- 노는 CPU가 없을 때 효율적임.

### 2. **대기 시간**
- 프로세스가 대기 큐에서 기다린 시간의 총합.<br>
- 대기 시간이 짧을수록 시스템 효율성이 높아짐.

### 3. **턴어라운드 시간(Turnaround Time)**
- 프로세스가 실행을 시작하고 끝날 때까지 걸린 시간.<br>
- 짧은 턴어라운드 시간을 목표로 해야 함.

### 4. **처리량(Throughput)**
- 시간당 처리된 프로세스 수를 의미.<br>
- 많은 프로세스를 처리하는 것이 중요

### 5. **응답 시간(Response Time)**
- 프로세스가 시작된 시점부터 처음으로 응답이 나오는 시간.<br>
- **대화형 시스템**에서는 응답 시간이 중요한 성능 지표로 작용.<br><br><br>



# Spring AOP & 프록시 개념

## AOP의 개념

> Aspect
> - 반복되어 사용되는 로직.<br>
>   로깅, 보안 체크, 트랜잭션 처리와 같은 공통 기능이 Aspect에 해당함.<br>
>   여러 클래스에 걸쳐 재사용될 공통 기능이라면, 단일 Aspect로 정의한 후 요소요소에 적용 가능

> Target
> - AOP가 적용될 핵심 비즈니스 로직을 담고 있는 객체.<br>
>   Target 객체는 일반적으로 실제 동작하는 비즈니스 로직을 처리하는 클래스.

> Advice
> - Aspect가 실제로 수행하는 로직.<br>
>   즉, 반복되는 공통 기능이 Advice로 정의되며, 언제 이 로직이 실행될지 설정 가능<br>

> JointPoint, PointCut
> - JointPoint는 Advice가 실행될 수 있는 지점을 의미함.<br>
>   즉, 어떤 메소드 실행 전에 또는 후에 Advice가 실행될지에 대한 위치를 지정하는 것임.<br>
>   PointCut은 실제 Advice가 적용될 위치를 구체적으로 지정하는 표현식임.<br>
>   이를 통해 특정 메소드, 특정 클래스에만 AOP를 적용할 수 있음.

## 스프링 AOP에서의 어노테이션

- `@Before` -> 타겟 메소드 호출 전 어드바이스 기능을 수행.<br>
  핵심 메소드 실행 전 로깅, 보안 체크 등의 작업을 미리 처리하고 싶은 경우 사용.

- `@After` -> 타겟 메소드 완료된 후 어드바이스 기능 수행.<br>
  이 어드바이스는 메소드 실행 여부와 관계없이 실행됨 = 오류나고 예외 던져도 일단 실행됨<br>

- `@AfterReturning` -> 타겟 메소드 성공 후에 어드바이스 기능을 수행.<br>
  반환값을 가지구 추가적인 작업을 수행하고 싶은 경우 사용.

- `@AfterThrowing` -> 타겟 메소드 예외 발생 시 어드바이스 기능 수행.<br>
  예외처리, 롤백 등에 사용.

- `@Around` -> 타겟 메소드를 감쌈. 호출 전후에 어드바이스 기능 수행.<br>
  메소드의 실행을 제어할 수 있어, 타겟 메소드가 실행되기 전에 로직을 실행하거나, 실행 후에 결과값을 변경할 수 있음.<br>
  가장 강력하며, 복잡한 AOP 로직을 처리할 수 있음.

## AOP 적용 대상
AOP는 스프링의 Bean에만 적용될 수 있음.<br>
따라서 AOP를 적용하려면 스프링 컨테이너에서 관리되는 Bean이어야 함.<br>
스프링은 Bean에 대한 프록시를 생성하여, 해당 Bean에 AOP를 적용할 수 있도록 처리함.

## 프록시(Proxy)란?

객체를 대신하여 특정 작업을 수행할 수 있도록 만들어진 객체<br>
스프링 AOP에서 프록시는 실제 대상 객체(Target)를 감싸 대상에 대한 호출을 가로채 추가 작업 수행.<br>
프록시를 통해 AOP 기능을 적용하면, 핵심 로직을 건들지 않고도 부가적 로직을 삽입할 수 있음.

## 프록시의 종류

스프링에서는 두 가지 종류의 프록시를 제공함.

### 1. JDK 동적 프록시 (Interface 기반)
- 인터페이스를 기반으로 생성되는 프록시임.<br>
- 인터페이스를 구현하는 객체를 프록시로 감싸게 됨.<br>
- 클래스가 아닌 인터페이스를 기준으로 프록시가 생성되기 때문에, 인터페이스가 필요함.
- 주로 `@AspectJ`나 `@Before` 등의 AOP를 적용할 때 사용됨.
- 기본적으로 인터페이스 기반의 프록시가 생성됨.

### 2. CGLIB 프록시 (Class 기반)
- 클래스 기반으로 생성되는 프록시임.<br>
- 클래스가 상속을 받아서 프록시가 생성됨.<br>
- 인터페이스를 사용하지 않고 클래스 자체를 기반으로 하여 프록시를 생성하기 때문에, 인터페이스가 필요하지 않음.
- 클래스에 대한 AOP가 필요한 경우 사용.
- `@EnableAspectJAutoProxy(proxyTargetClass = true)`로 설정하면 CGLIB 방식으로 프록시가 생성됨.

## 프록시의 역할

프록시는 실제로 메소드 호출을 가로채어 부가적인 처리를 한 후, 원래의 메소드(핵심 로직)를 호출하게 됨.<br>
따라서 프록시가 생성되면 대상 객체는 프록시 객체로 대체되고, 프록시가 호출될 때마다 실제 메소드 호출 전후로 부가적인 어드바이스를 수행함.<br>
이렇게 하면 AOP를 통해 핵심 로직과 부가 로직을 분리할 수 있음.

## 프록시와 AOP

AOP를 적용하는 과정에서 프록시는 중요한 역할을 함.<br>
스프링 AOP는 기본적으로 대상 객체를 감싸게 됨.<br>
따라서 프록시 객체는 AOP의 기능을 적용한 메소드 호출을 대신하며, 해당 메소드에 어드바이스를 삽입하여 추가적인 처리를 수행함.
